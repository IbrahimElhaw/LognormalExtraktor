def correct_D():
    # regenerated_curve2 =np.zeros_like(timestamps_arr)
    # bestMSE = float("inf")
    # for i in range(100):
    #     strokes2=[(strokes[0][0]+5*i, strokes[0][1], strokes[0][2], strokes[0][3])]
    #     regenerated_curve2 = generate_curve_from_parameters(strokes2,timestamps_arr)
    #     actualMSE = utilities.calculate_MSE(regenerated_curve2, smoothed_velocity)
    #     if actualMSE > bestMSE:
    #         break
    #     bestMSE = actualMSE
    # print(utilities.calculate_MSE(regenerated_curve, smoothed_velocity))
    # print(utilities.calculate_MSE(regenerated_curve2, smoothed_velocity))
    pass


def draw_movement(strokes, timestamps_arr):
    # t1_t5 = get_t1_t5_list(strokes, timestamps_arr)
    # angles = start_and_end_angles(t1_t5, timestamps_arr, x_values, y_values)
    # X = np.zeros_like(timestamps_arr)
    # Y = np.zeros_like(timestamps_arr)
    # print(strokes)
    # print(np.degrees(angles))
    # # angles = np.where(angles < 0, np.pi + angles, angles)
    # for stroke, angle in zip(strokes, angles):
    #     X2, Y2 = draw_stroke(stroke[0], angle[1], angle[0], timestamps_arr, stroke[3], stroke[2], stroke[1])
    #     X2 = np.where(np.isnan(X2), 0, X2)
    #     Y2 = np.where(np.isnan(Y2), 0, Y2)
    #     X+=X2
    #     Y+=Y2
    #     plt.plot(x_values, y_values, label="original")
    #     plt.plot(X,Y, label="generated")
    #     plt.legend()
    #     plt.show()
    # X= np.array(X)
    # Y= np.array(Y)
    # X-=np.min(X)
    # Y-=np.min(Y)
    # plt.plot(x_values, y_values, color="grey", label="original")
    # plt.plot(X, Y, color="black", label="generated")
    # plt.legend()
    # plt.show()
    # return X, Y
    pass